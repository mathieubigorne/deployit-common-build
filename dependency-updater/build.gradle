// TODO checkVersions should include the pom.xml in a project

buildscript {
  repositories { mavenCentral() }
  dependencies {
    classpath 'com.typesafe:config:1.2.0'
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.6'
  }
}

def projectData(def repoName, def cfgs = [ 'depcfg' ]) {
  return [ repoName, [ url: "git@github.com:xebialabs/${repoName}.git", toUpdate: cfgs ] ]
}

def mainProjectNames = ['cloud-pack', 'xl-deploy']

def middlewarePluginNames = ['tomcat-plugin', 'biztalk-plugin', 'glassfish-plugin', 'jbossas-plugin', 'jbossdm-plugin',
        'loadbalancer-plugin', 'websphere-plugins', 'windows-plugin', 'iis-plugin', 'weblogic-plugins', 'rpm-plugin']

def miscProjectNames = ['online-docs', 'online-docs-jekyll', 'xl-config-compare', 'xl-download']


// The keys of mainProjectData should match with repository name from the URL
ext {
  mainProjectData = mainProjectNames.collect( { projectData(it)})
  middleWarePluginProjectData = middlewarePluginNames.collect( { projectData(it) } )
  miscProjectData = miscProjectNames.collect( { projectData(it) } )
  ciPluginProjectData = [
          projectData('bamboo-xl-deploy-plugin', ['depcfg', 'pom']),
          projectData('maven-deployit-plugin', ['pom'])
  ]
  testData = [ projectData('temp4test', [ 'depcfg', 'pom']) ]

  pluginProjectData = ciPluginProjectData + middleWarePluginProjectData
  projectData = mainProjectData + pluginProjectData + miscProjectData + testData

  propToProject = [ 'xlPlatformVersion'     : 'xl-platform',
                    'xlDeployVersion'       : 'xl-deploy',
                    'licenseDatabaseVersion': 'license-database',
                    'cloudPackVersion'      : 'cloud-pack',
                    'docBaseStyleVersion'   : 'doc-base-style',
                    'overthereVersion'      : 'overthere',
                    'overcastVersion'       : 'overcast',
                    'compareVersion'        : 'xl-config-compare']

  versionProperties = propToProject.keySet().sort(false)

  numInconsistencies = 0
}

description = """
Use this gradle build to update the gradle/dependencies.conf, pom.xml and/or gradle
distribution URL's across many projects. The pom.xml has to have a special format
with a properties section with the same property names as the supported properties
as described below.

You can do single updates or update groups of projects.

Supported properties:
    ${versionProperties.join(',\n    ')}

If a property is not present in the dependencies.conf it will not be
added/updated.

So to update all XL Deploy dependencies:

    gradle groupUpdateXlDeployDependencies \\
      -PxlPlatformVersion=5.0.1 \\
      -Pbranch=master

Or using task abbreviations:

    gradle gUXD -PxlPlatformVersion=5.0.1 -PxlDeployVersion=5.0.1  -Pbranch=master

To update only the jenkins deployit plugin:

    gradle updateJenkinsDeployitPluginDependencies -PxlPlatformVersion=5.0.1 -Pbranch=master

To specify the branch you want to update use -Pbranch=<branch>. There is no
default by design.

    gradle groupUpdateXlDeployDependencies \\
      -PoverthereVersion=2.4.1 \\
      -Pbranch=4.0.x-maintenance

To update gradle wrappers use the update<plugin>Gradle or
groupUpdate<group>Gradle tasks with an additional property
'gradleDistributionUrl'. For instance:

    gradle groupUpdateXlDeployGradle \\
        -PgradleDistributionUrl=http://tech.xebialabs.com/xebialabs-gradle/xebialabs-gradle-1.11-1.2.21-bin.zip \\
        -Pbranch=master

Authentication

To authenticate generate a oauth token for your github account and give
it access to private repositories.

Put the token in your private gradle.properties with key

    githubOauthToken=<yourkey>

"""

gradle.buildStarted {
  numInconsistencies = 0
}
gradle.buildFinished { buildresult ->
  if(numInconsistencies > 0) {
    throw new RuntimeException("${numInconsistencies} inconsistencies found.")
  }
}

def projectName(def name) {
  def parts = name.split('-')
  parts*.capitalize().join()
}

def updateProjectDependencyTaskName(def name) {
  "update${projectName(name)}Dependencies"
}

def updateProjectGradleTaskName(def name) {
  "update${projectName(name)}Gradle"
}

import com.typesafe.config.ConfigFactory
import com.typesafe.config.ConfigValueType
import com.typesafe.config.ConfigRenderOptions
import com.typesafe.config.ConfigParseOptions

projectData.each { repoName, metadata ->
  def updateProjDepTask = task("${updateProjectDependencyTaskName(repoName)}" {
    group = "Single project update"
    description = "Update"
  })

  if( metadata.toUpdate.contains('depcfg') ) {
    def updateDefCfgTask = defineUpdateDefCfgTask(repoName)
    defineUpdateProjectGradleTask(repoName)

    updateProjDepTask.dependsOn updateDefCfgTask
    updateProjDepTask.description += " gradle/dependencies.conf"
  }

  if( metadata.toUpdate.contains('pom') ) {
    def updatePomTask = defineUpdatePomTask(repoName)
    updateProjDepTask.dependsOn updatePomTask
    updateProjDepTask.description += " pom.xml"
  }
}


def defineUpdateDefCfgTask(repoName) {
  task "update${projectName(repoName)}DepCfg" (type: UpdateGithubFile) {
    group = "Single project gradle/dependency.conf update"

    repository = repoName
    contentPath = 'gradle/dependencies.conf'

    doUpdate { content ->
      def parseOptions = ConfigParseOptions.defaults().setOriginDescription("Github project $repoName branch $branch gradle/dependencies.conf")
      def cfg = ConfigFactory.parseString(content, parseOptions)
      def updates = [:]
      def updatedToList = []

      versionProperties.grep{ project.hasProperty(it) && cfg.hasPath("xebialabs.dependencies.versions.${it}") }.each {
        def key = "xebialabs.dependencies.versions.${it}"
        def requestedProject = propToProject[it]
        def requestedVersion = project.getProperty(it)
        def currentVersion = cfg.getString(key)
        if (!requestedVersion.equals(currentVersion)) {
          logger.info("$repoName: Updating $it $currentVersion -> $requestedVersion")
          updatedToList += "$requestedProject-$requestedVersion"
          updates[key] = requestedVersion
        } else {
          logger.debug("$repoName: Not updating $it: $requestedProject already at version $requestedVersion")
        }
      }

      cfg = ConfigFactory.parseMap(updates, "updated values").withFallback(cfg)

      def rendered = cfg.root().render(ConfigRenderOptions.defaults().setOriginComments(false).setJson(false))

      (updatedToList.size() > 0) ? [content: rendered, message: updatedToList.join(', ')] : [:]
    }
  }
}


def defineUpdateProjectGradleTask(repoName) {

  task "${updateProjectGradleTaskName(repoName)}"(type: UpdateGithubFile) {
    group = "Single project Gradle Wrapper Update"

    repository = repoName
    contentPath = 'gradle/wrapper/gradle-wrapper.properties'

    doUpdate { content ->
      if (!project.hasProperty('gradleDistributionUrl')) {
        throw new RuntimeException("Property gradleDistributionUrl not set, don't know which gradle to update to.")
      }
      def requestedGradleUrl = project.getProperty('gradleDistributionUrl')

      Properties props = new Properties()
      props.load(new StringReader(content))
      def currentUrl = props['distributionUrl']

      if (requestedGradleUrl.equals(currentUrl)) {
        logger.debug("$repoName: Not updating gradle distributionUrl: already at $currentUrl")
        return [:]
      }

      logger.info("$repoName: Updating gradle distribution $currentUrl -> $requestedGradleUrl")
      props['distributionUrl'] = requestedGradleUrl
      def newContent = new StringWriter()
      props.store(newContent, null)

      String gradleVersion = requestedGradleUrl.substring(requestedGradleUrl.lastIndexOf('/') + 1).replace('-bin.zip', '')
      [content: newContent.toString(), message: gradleVersion]
    }
  }
}

def defineUpdatePomTask(repoName) {
  task "update${projectName(repoName)}Pom" (type: UpdateGithubFile) {
    group = "Single project pom.xml update"

    repository = repoName
    contentPath = 'pom.xml'

    doUpdate { content ->
      def newContent = new StringWriter()

      boolean insidePropertiesTag = false
      def updatedToList = []
      def matcher

      content.eachLine { contentLine ->
        def outputLine = contentLine
        if (!insidePropertiesTag && contentLine ==~ /^\s+<properties>\s*$/) {
          insidePropertiesTag = true;
        } else if (insidePropertiesTag && contentLine ==~ "^\\s+</properties>\\s*\$") {
          insidePropertiesTag = false;
        } else if (insidePropertiesTag && (matcher = (contentLine =~ /^(\s+)<(\w+)>(.+)<\/\w+>(\s*)$/))) {
          def leadingWhitespace = matcher[0][1]
          def propertyName = matcher[0][2]
          def currentVersion = matcher[0][3]
          def trailingWhitespace = matcher[0][4]

          if (project.hasProperty(propertyName) && versionProperties.contains(propertyName)) {
            def requestedVersion = project.getProperty(propertyName)
            def requestedProject = propToProject[propertyName]
            if (!requestedVersion.equals(currentVersion)) {
              logger.info("$repoName: Updating $propertyName $currentVersion -> $requestedVersion")
              updatedToList += "$requestedProject-$requestedVersion"
            } else {
              logger.debug("$repoName: Not updating $contentLine: $requestedProject already at version $requestedVersion")
            }
            outputLine = "${leadingWhitespace}<${propertyName}>${requestedVersion}</${propertyName}>${trailingWhitespace}"
          }
        }
        newContent.println outputLine
      }

      (updatedToList.size() > 0) ? [content: newContent.toString(), message: updatedToList.join(', ')] : [:]
    }
  }
}

///// Dependency group update tasks

def getUpdateTask(def cfg, def projectName) {
  ( cfg.toUpdate.contains('depcfg') || cfg.toUpdate.contains('pom') ) ?  "${updateProjectDependencyTaskName(projectName)}" : null
}

def getPluginName(def cfg, def task) {
  (cfg.toUpdate.contains('depcfg') || cfg.toUpdate.contains('pom')) ? task : null
}

def nextLine = ',\n    '
for (taskDef in [
        [name: "groupUpdateXlDeployDependencies", data: mainProjectData],
        [name: "groupUpdateCiPluginDependencies", data: ciPluginProjectData],
        [name: "groupUpdateMiddleWarePluginDependencies", data: middleWarePluginProjectData],
        [name: "groupUpdatePluginDependencies", data: pluginProjectData],
        [name: "groupUpdateAllDependencies", data: projectData],
]) {
  task "${taskDef.name}"(dependsOn: taskDef.data.findResults { getUpdateTask(it[1], it[0]) }) {
    group "Group update"
    description = "Update ${taskDef.data.findResults { getPluginName(it[1], it[0]) }.join(nextLine)}"
  }
}

for (taskDef in [
        [name: "groupUpdateXlDeployGradle", data: mainProjectData],
        [name: "groupUpdatePluginGradle", data: pluginProjectData],
        [name: "groupUpdateAllGradle", data: projectData],
]) {
  task "${taskDef.name}"(dependsOn: taskDef.data.findResults { it[1].toUpdate.contains('depcfg') ? "${updateProjectGradleTaskName(it[0])}" : null }) {
    group "Group gradle update"
    description = "Update ${mainProjectData.findResults { it[1].toUpdate.contains('depcfg') ? it[0] : null }.join(nextLine)}"
  }
}

////// Check targets

def getGradleVersionFromUrl(def url) {
  def start = url.lastIndexOf('/') + 1
  def end = url.lastIndexOf('-bin.zip')
  if (end == -1) {
    end = url.length()
  }
  url.substring(start, end)
}

task checkGradleWrappers(type: CheckGithubFile) {
  group = "Check that gradle wrappers are the same across projects"

  repositories = projectData.findResults { it[1].toUpdate.contains('depcfg') ? it[0] : null }
  contentPath = 'gradle/wrapper/gradle-wrapper.properties'

  def nonMatching = []
  def touchstoneUrl = null

  check { repository, content ->
    logger.debug("Checking $repository...")
    def currentUrl = readDistributionUrl(content)
    logger.info("${repository}:\n\t Touchstone URL=${touchstoneUrl}\n\t Current    URL=${currentUrl}")
    if (touchstoneUrl == null) {
      logger.warn("Touchstone gradle wrapper url taken from $repository: $currentUrl")
      touchstoneUrl = currentUrl;
    } else {
      if (!currentUrl.equals(touchstoneUrl)) {
        if (currentUrl == null) {
            logger.warn "No distributionUrl defined in $repository $contentPath; not registering it as non-matching!"
        } else {
            nonMatching += [[repository, touchstoneUrl, currentUrl]]
        }
      }
    }
  }

  doLast {
    if (nonMatching.size() > 0) {
      project.ext.numInconsistencies += nonMatching.size()
      nonMatching.each { repo, goodUrl, url ->
        logger.error "$repo gradle version is ${getGradleVersionFromUrl(url)} not ${getGradleVersionFromUrl(goodUrl)}"
      }
    }
  }
}

def readDistributionUrl(content) {
  Properties props = new Properties();
  props.load(new StringReader(content))
  props['distributionUrl']
}

def renderCfg(def cfg) {
  cfg.root().render(ConfigRenderOptions.defaults().setOriginComments(false).setJson(false))
}

def getEntryValue(def cfg, def entry) {
  if (entry.getValue().valueType() == ConfigValueType.STRING) {
    cfg.getString(entry.getKey())
  } else if (entry.getValue().valueType() == ConfigValueType.NUMBER) {
    cfg.getNumber(entry.getKey()).toString()
  } else {
    throw new RuntimeException("$repository: gradle/dependencies.conf has key ${entry.getKey()} with unsupported type ${entry.getValue().valueType()}");
  }
}

task checkVersions(type: CheckGithubFile) {
  group = "Check that gradle wrappers are the same across projects"
  description = "Check gradle wrapper versions in ${repositories.join(' ')}"

  repositories = projectData.grep{it[1].toUpdate.contains('depcfg')}.collect{it[0]}
  contentPath = 'gradle/dependencies.conf'

  def nonMatching = []
  def touchstoneCfg = null

  check { repository, content ->
    logger.debug("Checking $repository...")
    def parseOptions = ConfigParseOptions.defaults().setOriginDescription("Github project ${repository} branch $branch gradle/dependencies.conf")
    def cfg = ConfigFactory.parseString(content, parseOptions)
    if (touchstoneCfg == null) {
      logger.warn("Repository $repository provides touchstone configuration for versions: ${renderCfg(cfg)}")
      touchstoneCfg = cfg
    } else {
      cfg.entrySet().grep { it.getKey().startsWith('xebialabs.dependencies.versions')}.each { entry ->
        String key = entry.getKey()
        def value = getEntryValue(cfg, entry)

        if (touchstoneCfg.hasPath(key)) {
          def touchstoneValue = touchstoneCfg.getString(key)
          if (!touchstoneValue.equals(value)) {
            nonMatching += [[repository, key, touchstoneValue, value]]
          }
        } else {
          logger.warn("Repository $repository adds $key=$value to touchstone configuration")
          touchstoneCfg = ConfigFactory.parseMap([ ({-> key}()) : value], "updated values").withFallback(touchstoneCfg)
        }
      }
    }
  }
  doLast {
    if (nonMatching.size() > 0) {
      project.ext.numInconsistencies += nonMatching.size()
      nonMatching.each { repo, key, touchstoneValue, value ->
        println "Repository $repo: key $key has value $value while $touchstoneValue was expected"
      }
    }
  }
}

import groovyx.net.http.RESTClient
import static groovyx.net.http.ContentType.JSON
import org.apache.http.*
import org.apache.http.protocol.*
import org.apache.http.auth.*

class GitHubTask extends DefaultTask {
  String username = "${ -> project.githubOauthToken }"
  String password = 'x-oauth-basic'
  String organization = 'xebialabs'
  String contentPath
  def ignoreMissing = true
  def branch = "${ -> project.branch}"

  def github() {
    // set auth header manually else it doesn't work
    def userPassBase64 = "${username}:${password}".toString().bytes.encodeBase64()

    return new RESTClient("https://api.github.com/").with {
      contentType = JSON
      defaultRequestHeaders.'Authorization' = "Basic $userPassBase64"
      defaultRequestHeaders.'Accept' = 'application/vnd.github.v3+json'
      // will not work without User-Agent!
      defaultRequestHeaders.'User-Agent' = 'GradleGithubTask'
      handler.failure = { resp ->
        throw new RuntimeException("GitHub API Failure: ${resp.statusLine}")
      }
      delegate
    }
  }

  def checkBranch() {
    try {
      if (!"${branch}".trim()) {
        throw new RuntimeException("Task ${name} requires you to specify a branch, ex. -Pbranch=master")
      }
    } catch (MissingPropertyException e) {
      throw new RuntimeException("Task ${name} requires you to specify a branch, ex. -Pbranch=master", e)
    }
  }

  def doWithRepo(def repository, Closure action) {
    try {
      def contentUrl = "/repos/$organization/$repository/contents/$contentPath"
      def response = github().get(path: contentUrl, query: ['ref': "${branch}".toString()])
      def content = new String(response.data.content.decodeBase64(), 'UTF-8');
      def sha = response.data.sha
      action(contentUrl, content, sha)
    } catch (RuntimeException e) {
      if(ignoreMissing) {
        logger.warn("Could not access repository $repository branch $branch => skipping")
      } else {
        throw new RuntimeException("Failed to read from repository $repository ($branch)", e)
      }
    }
  }
}


class UpdateGithubFile extends GitHubTask {
  String repository
  Closure doUpdate

  @TaskAction
  def update() {
    checkBranch()
    doWithRepo(repository, { url, content, sha ->
      logger.debug("Loaded from '{}': '{}'", url, content)

      def updateMap = doUpdate content
      if (updateMap.size() > 0) {
        logger.debug("Updating with {}", updateMap)

        def body = ['content': updateMap.content.bytes.encodeBase64().toString(),
                    'message': updateMap.message.toString(),
                    'sha': sha,
                    'branch': "${branch}".toString()]
        logger.debug("Update request body: {}", body)

        def putResponse = github().put('path': url, 'body': body)
        logger.debug("Update response: {}", putResponse.data)
      } else {
        logger.debug("No update to do.")
      }
    })
  }
}

class CheckGithubFile extends GitHubTask {
  def repositories = []
  Closure check

  @TaskAction
  def check() {
    checkBranch()
    repositories.each { repository ->
      def content = ""
      doWithRepo(repository, { url, urlContent, sha ->
        content = urlContent
        logger.debug("Loaded from '{}': '{}'", url, content)
      })

      check repository, content
    }
  }
}
